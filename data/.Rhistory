xg <- x[which(x < 0)[0] - 1]
yg <- y[which.max(y<0) -1]
yg <- y[which.max(y<0) -1]
xg <- x[which.max(y<0) -1]
# Pozisyonlarin plot edilmesi
plot(x, y, type="l", xlab="x (m)", ylab="y (m)", main="Projectile Motion", col="blue")
points(xg,yg,col="red",pch=5)
# Pozisyonlarin plot edilmesi
plot(x, y, type="l", xlab="x (m)", ylab="y (m)", main="Projectile Motion", col="blue")
points(xg,yg,col="red",pch=19)
G <- 9.81
v0 <- 50
theta <- 20
theta_rad <- theta * (pi/180)
# baslangic pozisyonu
x0 <- 0
y0 <- 0
# hizin x ve y bileseni
vx0 <- v0 * cos(theta_rad)
vy0 <- v0 * sin(theta_rad)
# zaman degisenleri
t0 <- 0
tf <- 10
dt = 0.01
# adimlarin hesaplanmasi
N <- as.integer(((tf-t0)/dt))
t <- seq(t0,tf,length.out = N)
# N uzunlugunda sequencelerin olusturulmasi
x <- c(x0,rep(0,N-1))
y <- c(y0,rep(0,N-1))
vx <- c(vx0,rep(0,N-1))
vy <- c(vy0,rep(0,N-1))
# Euler metodu
for (i in 2:N) {
x[i] <- x[i-1] + vx[i-1] * dt
y[i] <- y[i-1] + vy[i-1] * dt
vx[i] <- vx[i-1]
vy[i] <- vy[i-1] - G * dt
}
yg <- y[which.max(y<0) -1]
xg <- x[which.max(y<0) -1]
# Pozisyonlarin plot edilmesi
plot(x, y, type="l", xlab="x (m)", ylab="y (m)", main="Projectile Motion", col="blue")
points(xg,yg,col="red")
G <- 9.81
v0 <- 50
theta <- 45
theta_rad <- theta * (pi/180)
# baslangic pozisyonu
x0 <- 0
y0 <- 0
# hizin x ve y bileseni
vx0 <- v0 * cos(theta_rad)
vy0 <- v0 * sin(theta_rad)
# zaman degisenleri
t0 <- 0
tf <- 10
dt = 0.01
# adimlarin hesaplanmasi
N <- as.integer(((tf-t0)/dt))
t <- seq(t0,tf,length.out = N)
# N uzunlugunda sequencelerin olusturulmasi
x <- c(x0,rep(0,N-1))
y <- c(y0,rep(0,N-1))
vx <- c(vx0,rep(0,N-1))
vy <- c(vy0,rep(0,N-1))
# Euler metodu
for (i in 2:N) {
x[i] <- x[i-1] + vx[i-1] * dt
y[i] <- y[i-1] + vy[i-1] * dt
vx[i] <- vx[i-1]
vy[i] <- vy[i-1] - G * dt
}
yg <- y[which.max(y<0) -1]
xg <- x[which.max(y<0) -1]
# Pozisyonlarin plot edilmesi
plot(x, y, type="l", xlab="x (m)", ylab="y (m)", main="Projectile Motion", col="blue")
points(xg,yg,col="red")
G <- 9.81
v0 <- 50
theta <- 45
theta_rad <- theta * (pi/180)
# baslangic pozisyonu
x0 <- 0
y0 <- 0
# hizin x ve y bileseni
vx0 <- v0 * cos(theta_rad)
vy0 <- v0 * sin(theta_rad)
# zaman degisenleri
t0 <- 0
tf <- 10
dt = 0.01
# adimlarin hesaplanmasi
N <- as.integer(((tf-t0)/dt))
t <- seq(t0,tf,length.out = N)
# N uzunlugunda sequencelerin olusturulmasi
x <- c(x0,rep(0,N-1))
y <- c(y0,rep(0,N-1))
vx <- c(vx0,rep(0,N-1))
vy <- c(vy0,rep(0,N-1))
# Euler metodu
for (i in 2:N) {
x[i] <- x[i-1] + vx[i-1] * dt
y[i] <- y[i-1] + vy[i-1] * dt
vx[i] <- vx[i-1]
vy[i] <- vy[i-1] - G * dt
}
yg <- y[which.max(y<0) -1]
xg <- x[which.max(y<0) -1]
# Pozisyonlarin plot edilmesi
plot(x, y, type="l", xlab="x (m)", ylab="y (m)", main="Projectile Motion", col="blue")
points(xg,yg,col="red",pch=19)
G <- 9.81
v0 <- 50
theta <- 45
theta_rad <- theta * (pi/180)
# baslangic pozisyonu
x0 <- 0
y0 <- 0
# hizin x ve y bileseni
vx0 <- v0 * cos(theta_rad)
vy0 <- v0 * sin(theta_rad)
# zaman degisenleri
t0 <- 0
tf <- 10
dt = 0.01
# adimlarin hesaplanmasi
N <- as.integer(((tf-t0)/dt))
t <- seq(t0,tf,length.out = N)
# N uzunlugunda sequencelerin olusturulmasi
x <- c(x0,rep(0,N-1))
y <- c(y0,rep(0,N-1))
vx <- c(vx0,rep(0,N-1))
vy <- c(vy0,rep(0,N-1))
# Euler metodu
for (i in 2:N) {
x[i] <- x[i-1] + vx[i-1] * dt
y[i] <- y[i-1] + vy[i-1] * dt
vx[i] <- vx[i-1]
vy[i] <- vy[i-1] - G * dt
}
yg <- floor(y[which.max(y<0) -1])
xg <- x[which.max(y<0) -1]
# Pozisyonlarin plot edilmesi
plot(x, y, type="l", xlab="x (m)", ylab="y (m)", main="Projectile Motion", col="blue")
points(xg,yg,col="red",pch=19)
G <- 9.81
v0 <- 50
theta <- 120
theta_rad <- theta * (pi/180)
# baslangic pozisyonu
x0 <- 0
y0 <- 0
# hizin x ve y bileseni
vx0 <- v0 * cos(theta_rad)
vy0 <- v0 * sin(theta_rad)
# zaman degisenleri
t0 <- 0
tf <- 10
dt = 0.01
# adimlarin hesaplanmasi
N <- as.integer(((tf-t0)/dt))
t <- seq(t0,tf,length.out = N)
# N uzunlugunda sequencelerin olusturulmasi
x <- c(x0,rep(0,N-1))
y <- c(y0,rep(0,N-1))
vx <- c(vx0,rep(0,N-1))
vy <- c(vy0,rep(0,N-1))
# Euler metodu
for (i in 2:N) {
x[i] <- x[i-1] + vx[i-1] * dt
y[i] <- y[i-1] + vy[i-1] * dt
vx[i] <- vx[i-1]
vy[i] <- vy[i-1] - G * dt
}
yg <- floor(y[which.max(y<0) -1])
xg <- x[which.max(y<0) -1]
# Pozisyonlarin plot edilmesi
plot(x, y, type="l", xlab="x (m)", ylab="y (m)", main="Projectile Motion", col="blue")
points(xg,yg,col="red",pch=19)
G <- 9.81
v0 <- 50
theta <- 40
theta_rad <- theta * (pi/180)
# baslangic pozisyonu
x0 <- 0
y0 <- 0
# hizin x ve y bileseni
vx0 <- v0 * cos(theta_rad)
vy0 <- v0 * sin(theta_rad)
# zaman degisenleri
t0 <- 0
tf <- 10
dt = 0.01
# adimlarin hesaplanmasi
N <- as.integer(((tf-t0)/dt))
t <- seq(t0,tf,length.out = N)
# N uzunlugunda sequencelerin olusturulmasi
x <- c(x0,rep(0,N-1))
y <- c(y0,rep(0,N-1))
vx <- c(vx0,rep(0,N-1))
vy <- c(vy0,rep(0,N-1))
# Euler metodu
for (i in 2:N) {
x[i] <- x[i-1] + vx[i-1] * dt
y[i] <- y[i-1] + vy[i-1] * dt
vx[i] <- vx[i-1]
vy[i] <- vy[i-1] - G * dt
}
yg <- floor(y[which.max(y<0) -1])
xg <- x[which.max(y<0) -1]
# Pozisyonlarin plot edilmesi
plot(x, y, type="l", xlab="x (m)", ylab="y (m)", main="Projectile Motion", col="blue")
points(xg,yg,col="red",pch=19)
G <- 9.81
v0 <- 50
theta <- 40
theta_rad <- theta * (pi/180)
# baslangic pozisyonu
x0 <- 0
y0 <- 0
# hizin x ve y bileseni
vx0 <- v0 * cos(theta_rad)
vy0 <- v0 * sin(theta_rad)
# zaman degisenleri
t0 <- 0
tf <- 10
dt = 0.01
# adimlarin hesaplanmasi
N <- as.integer(((tf-t0)/dt))
t <- seq(t0,tf,length.out = N)
# N uzunlugunda sequencelerin olusturulmasi
x <- c(x0,rep(0,N-1))
y <- c(y0,rep(0,N-1))
vx <- c(vx0,rep(0,N-1))
vy <- c(vy0,rep(0,N-1))
# Euler metodu ile pozisyonlarin tayini
for (i in 2:N) {
x[i] <- x[i-1] + vx[i-1] * dt
y[i] <- y[i-1] + vy[i-1] * dt
vx[i] <- vx[i-1]
vy[i] <- vy[i-1] - G * dt
}
yg <- floor(y[which.max(y<0) -1])
xg <- x[which.max(y<0) -1]
# Pozisyonlarin plot edilmesi
plot(x, y, type="l", xlab="x (m)", ylab="y (m)", main="Projectile Motion", col="blue")
points(xg,yg,col="red",pch=19)
G <- 9.81
v0 <- 50
theta <- 40
theta_rad <- theta * (pi/180)
# baslangic pozisyonu
x0 <- 0
y0 <- 0
# hizin x ve y bileseni
vx0 <- v0 * cos(theta_rad)
vy0 <- v0 * sin(theta_rad)
# zaman degisenleri
t0 <- 0
tf <- 10
dt = 0.01
# adimlarin hesaplanmasi
N <- as.integer(((tf-t0)/dt))
t <- seq(t0,tf,length.out = N)
# N uzunlugunda sequencelerin olusturulmasi
x <- c(x0,rep(0,N-1))
y <- c(y0,rep(0,N-1))
vx <- c(vx0,rep(0,N-1))
vy <- c(vy0,rep(0,N-1))
# Pozisyonlarin tayini
for (i in 2:N) {
x[i] <- x[i-1] + vx[i-1] * dt
y[i] <- y[i-1] + vy[i-1] * dt
vx[i] <- vx[i-1]
vy[i] <- vy[i-1] - G * dt
}
yg <- floor(y[which.max(y<0) -1])
xg <- x[which.max(y<0) -1]
# Pozisyonlarin plot edilmesi
plot(x, y, type="l", xlab="x (m)", ylab="y (m)", main="Projectile Motion", col="blue")
points(xg,yg,col="red",pch=19)
G <- 9.81
v0 <- 100
theta <- 40
theta_rad <- theta * (pi/180)
# baslangic pozisyonu
x0 <- 0
y0 <- 0
# hizin x ve y bileseni
vx0 <- v0 * cos(theta_rad)
vy0 <- v0 * sin(theta_rad)
# zaman degisenleri
t0 <- 0
tf <- 10
dt = 0.01
# adimlarin hesaplanmasi
N <- as.integer(((tf-t0)/dt))
t <- seq(t0,tf,length.out = N)
# N uzunlugunda sequencelerin olusturulmasi
x <- c(x0,rep(0,N-1))
y <- c(y0,rep(0,N-1))
vx <- c(vx0,rep(0,N-1))
vy <- c(vy0,rep(0,N-1))
# Pozisyonlarin tayini
for (i in 2:N) {
x[i] <- x[i-1] + vx[i-1] * dt
y[i] <- y[i-1] + vy[i-1] * dt
vx[i] <- vx[i-1]
vy[i] <- vy[i-1] - G * dt
}
yg <- floor(y[which.max(y<0) -1])
xg <- x[which.max(y<0) -1]
# Pozisyonlarin plot edilmesi
plot(x, y, type="l", xlab="x (m)", ylab="y (m)", main="Projectile Motion", col="blue")
points(xg,yg,col="red",pch=19)
G <- 9.81
v0 <- 100
theta <- 20
theta_rad <- theta * (pi/180)
# baslangic pozisyonu
x0 <- 0
y0 <- 0
# hizin x ve y bileseni
vx0 <- v0 * cos(theta_rad)
vy0 <- v0 * sin(theta_rad)
# zaman degisenleri
t0 <- 0
tf <- 10
dt = 0.01
# adimlarin hesaplanmasi
N <- as.integer(((tf-t0)/dt))
t <- seq(t0,tf,length.out = N)
# N uzunlugunda sequencelerin olusturulmasi
x <- c(x0,rep(0,N-1))
y <- c(y0,rep(0,N-1))
vx <- c(vx0,rep(0,N-1))
vy <- c(vy0,rep(0,N-1))
# Pozisyonlarin tayini
for (i in 2:N) {
x[i] <- x[i-1] + vx[i-1] * dt
y[i] <- y[i-1] + vy[i-1] * dt
vx[i] <- vx[i-1]
vy[i] <- vy[i-1] - G * dt
}
yg <- floor(y[which.max(y<0) -1])
xg <- x[which.max(y<0) -1]
# Pozisyonlarin plot edilmesi
plot(x, y, type="l", xlab="x (m)", ylab="y (m)", main="Projectile Motion", col="blue")
points(xg,yg,col="red",pch=19)
G <- 9.81
v0 <- 300
theta <- 20
theta_rad <- theta * (pi/180)
# baslangic pozisyonu
x0 <- 0
y0 <- 0
# hizin x ve y bileseni
vx0 <- v0 * cos(theta_rad)
vy0 <- v0 * sin(theta_rad)
# zaman degisenleri
t0 <- 0
tf <- 10
dt = 0.01
# adimlarin hesaplanmasi
N <- as.integer(((tf-t0)/dt))
t <- seq(t0,tf,length.out = N)
# N uzunlugunda sequencelerin olusturulmasi
x <- c(x0,rep(0,N-1))
y <- c(y0,rep(0,N-1))
vx <- c(vx0,rep(0,N-1))
vy <- c(vy0,rep(0,N-1))
# Pozisyonlarin tayini
for (i in 2:N) {
x[i] <- x[i-1] + vx[i-1] * dt
y[i] <- y[i-1] + vy[i-1] * dt
vx[i] <- vx[i-1]
vy[i] <- vy[i-1] - G * dt
}
yg <- floor(y[which.max(y<0) -1])
xg <- x[which.max(y<0) -1]
# Pozisyonlarin plot edilmesi
plot(x, y, type="l", xlab="x (m)", ylab="y (m)", main="Projectile Motion", col="blue")
points(xg,yg,col="red",pch=19)
G <- 9.81
v0 <- 50
theta <- 20
theta_rad <- theta * (pi/180)
# baslangic pozisyonu
x0 <- 0
y0 <- 0
# hizin x ve y bileseni
vx0 <- v0 * cos(theta_rad)
vy0 <- v0 * sin(theta_rad)
# zaman degisenleri
t0 <- 0
tf <- 10
dt = 0.01
# adimlarin hesaplanmasi
N <- as.integer(((tf-t0)/dt))
t <- seq(t0,tf,length.out = N)
# N uzunlugunda sequencelerin olusturulmasi
x <- c(x0,rep(0,N-1))
y <- c(y0,rep(0,N-1))
vx <- c(vx0,rep(0,N-1))
vy <- c(vy0,rep(0,N-1))
# Pozisyonlarin tayini
for (i in 2:N) {
x[i] <- x[i-1] + vx[i-1] * dt
y[i] <- y[i-1] + vy[i-1] * dt
vx[i] <- vx[i-1]
vy[i] <- vy[i-1] - G * dt
}
yg <- floor(y[which.max(y<0) -1])
xg <- x[which.max(y<0) -1]
# Pozisyonlarin plot edilmesi
plot(x, y, type="l", xlab="x (m)", ylab="y (m)", main="Projectile Motion", col="blue")
points(xg,yg,col="red",pch=19)
library(formattable)
library(FITSio)
library(formattable)
setwd("/Users/balkan/Projects/absorption-detection/data")
myevent <- dir()[2]
data <- readFITS(file = myevent)
standart_deviation <- function(x){
sqrt(sum((x-mean(x))^2)/(length(x)-1))
}
loglam <- formattable(matrix(unlist(data$col[which(data$colNames == "loglam")])), format = "f")
flux <- formattable(matrix(unlist(data$col[which(data$colNames == "model")])), format = "f")
wavelengths <- 10^loglam
df <- data.frame(wavelengths=wavelengths,flux=flux)
plot(wavelengths, flux, type = "l", xlab = "Wavelength (Angstrom)", ylab = "Flux",
main = "Spectrum")
decreasing_sequence <- FALSE
increasing_sequence <- FALSE
sequence_start_index <- NULL
absorption_line_indices <- c()
treshold <- mean(flux) - 2*standart_deviation(flux)
for (i in 2:(length(flux)-1)) {
# Flux bir oncekindek kucuk mu?
if (flux[i] < flux[i-1]) {
# Halihazirda decrasing sequence degilse baslat
if (!decreasing_sequence && !increasing_sequence) {
decreasing_sequence <- TRUE
sequence_start_index <- i - 1
}
increasing_sequence <- FALSE
# Flux bir oncekinden buyuk mu?
} else if (flux[i] > flux[i-1] && flux[i+1] > flux[i] && flux[i+2] > flux[i+1]) {
# decreasing sequenceyi durdur
if (decreasing_sequence) {
decreasing_sequence <- FALSE
min_index <- i-1
if(flux[sequence_start_index] - flux[min_index] > treshold){
absorption_line_indices <- c(absorption_line_indices, min_index )
}
}
increasing_sequence <- TRUE
} else {
# reset
decreasing_sequence <- FALSE
increasing_sequence <- FALSE
}
}
abs_w <- wavelengths[absorption_line_indices]
points(wavelengths[absorption_line_indices], flux[absorption_line_indices], col = "red", pch = 16,cex=0.5)
library(FITSio)
library(formattable)
setwd("/Users/balkan/Projects/absorption-detection/data")
myevent <- dir()[2]
data <- readFITS(file = myevent)
standart_deviation <- function(x){
sqrt(sum((x-mean(x))^2)/(length(x)-1))
}
loglam <- formattable(matrix(unlist(data$col[which(data$colNames == "loglam")])), format = "f")
flux <- formattable(matrix(unlist(data$col[which(data$colNames == "model")])), format = "f")
wavelengths <- 10^loglam
plot(wavelengths, flux, type = "l", xlab = "Wavelength (Angstrom)", ylab = "Flux",
main = "Spectrum")
decreasing_sequence <- FALSE
increasing_sequence <- FALSE
sequence_start_index <- NULL
absorption_line_indices <- c()
treshold <- mean(flux) - 2*standart_deviation(flux)
for (i in 2:(length(flux)-1)) {
# Flux bir oncekindek kucuk mu?
if (flux[i] < flux[i-1]) {
# Halihazirda decrasing sequence degilse baslat
if (!decreasing_sequence && !increasing_sequence) {
decreasing_sequence <- TRUE
sequence_start_index <- i - 1
}
increasing_sequence <- FALSE
# Flux bir oncekinden buyuk mu?
} else if (flux[i] > flux[i-1] && flux[i+1] > flux[i] && flux[i+2] > flux[i+1]) {
# decreasing sequenceyi durdur
if (decreasing_sequence) {
decreasing_sequence <- FALSE
min_index <- i-1
if(flux[sequence_start_index] - flux[min_index] > treshold){
absorption_line_indices <- c(absorption_line_indices, min_index )
}
}
increasing_sequence <- TRUE
} else {
# reset
decreasing_sequence <- FALSE
increasing_sequence <- FALSE
}
}
abs_w <- wavelengths[absorption_line_indices]
points(wavelengths[absorption_line_indices], flux[absorption_line_indices], col = "red", pch = 16,cex=0.5)
